# ロギング

## 概要

ログは、エンジニアが障害時に問題のある領域を特定するのを支援することを目的とした離散イベントです。

## 収集方法

ログ収集方法に関して言えば、標準的な手法の2つは、直接書き込みまたはエージェントベースのアプローチです。

直接書き込まれたログイベントは、通常、提供されたライブラリを利用して、特定のコンポーネントの処理中に処理されます。[Azure Monitor](https://azure.microsoft.com/en-us/services/monitor)には直接送信機能がありますが、本格的な/本番環境での使用はお勧めしません。このアプローチにはいくつかの利点があります。

- 構成または監視する外部プロセスはありません
- ディスク容量不足の問題を防ぐためのログファイル管理（ローリング、期限切れ）はありません。

このアプローチの潜在的なトレードオフ：

- 特定のライブラリがメモリバックアップバッファを使用している場合、メモリ使用量が増える可能性があります。
- 長時間のサービス停止が発生した場合、バッファの制約によりログデータが削除または切り捨てられる可能性があります。
- 複数コンポーネントのプロセスロギングは、ログを個別に管理および発行します。これは、アウトバウンド負荷の管理がより複雑になる可能性があります。

エージェントベースのログ収集は、ホストマシンで実行されている外部プロセスに依存しており、特定のコンポーネントがログデータの標準またはファイルを発行します。Kubernetesなどのコンテナ環境内でアプリケーションを実行する場合は、ログデータをstdoutに書き込むことをお勧めします。コンテナランタイムは、出力をファイルにリダイレクトします。ファイルは、エージェントによって処理されます。 [Azure Monitor](https://azure.microsoft.com/en-us/services/monitor), [Grafana Loki](https://github.com/grafana/loki) [ElasticのLogstash](https://www.elastic.co/logstash)や[Fluent Bit](https://fluentbit.io/)などは、ログ配布エージェントの例です。

エージェントを使用してログファイルを収集および送信する場合、いくつかの利点があります。

- 一元化された構成。
- 1つのプロセスで複数のデータソースを収集します。
- 中央サービスに送信する前のログデータのローカル前処理とフィルタリング。
- サービスの中断時にデータバッファとしてディスクスペースを利用する。

このアプローチにはトレードオフがあります。

- ログデータの処理に必要な専用のCPUおよびメモリリソース。
- バッファリング用の永続ディスクスペース。

## ベストプラクティス

- ロギングレベルに注意してください。ロギングが多すぎると、コストが増加し、アプリケーションのスループットが低下します。
- コードを変更せずにロギング構成を変更できることを確認してください。理想的には、アプリケーションを再起動せずに変更可能にします。
- 可能な場合は、カテゴリごとのログレベルを利用して、詳細なログ構成を可能にします。
- ログに記録する前にログレベルを確認して、割り当てと文字列操作のコストを回避します。
- 問題のあるリリースを特定できるように、サービスバージョンがログに含まれていることを確認してください。
- 発生した例外を1回だけログに記録します。ハンドラーでは、（特定の戻りコードを使用しても）正常に処理できる予想される例外のみをキャッチします。ログに記録して再スローする場合は、最上位の例外ハンドラーに任せてください。必要な最小限のクリーンアップ作業を実行してから、元のスタックトレースを維持するためにスローします。予想される例外（例：適切に予想される404、403 HTTPステータス）の警告またはスタックトレースをログに記録しないでください。
- 本番環境でログレベルを微調整します（たとえば、> =警告）。新しいリリースでは、バグの識別を容易にするために冗長性を高めることができます。
- サンプリングを使用する場合は、ロギングシステムで定義するのではなく、サービスレベルでこれを実装します。このようにして、ログに記録される内容を制御できます。追加の利点は、往復の回数が減ることです。
- ヘルスチェックとビジネス以外の要求による失敗のみを含めます。
- ダウンストリームシステムの誤動作によってログが繰り返し保存されないようにしてください。
- 車輪の再発明をしないでください。既存のツールを使用してデータを収集および分析してください。
- 個人を特定できる情報のポリシーと制限が守られていることを確認してください。
- 依存サービスのエラーと例外がキャプチャされ、ログに記録されるようにします。たとえば、アプリケーションがRedisキャッシュ、Service Bus、またはその他のサービスを使用している場合、これらのサービスへのアクセス中に発生したエラー/例外をキャプチャしてログに記録する必要があります。

### 十分なログデータがある場合、メトリックを計測する必要がありますか？

[ログとメトリック](../log-vs-metric.md) は、メトリックデータをいつ利用するか、およびログデータをいつ使用するかに関するいくつかの高レベルのガイダンスをカバーしています。どちらも、観察可能なシステムを作成する上で重要な役割を果たします。

### 何をログに記録するかを特定するのに問題がありますか？

**アプリケーションの起動時**:

- 起動時の回復不能なエラー。
- アプリケーションがまだ実行可能であるが期待どおりではない場合の警告（つまり、blob接続文字列を提供しないため、ローカルファイルに頼る。別の例は、セカンダリサービスまたは既知の良好な状態にフェールバックする必要がある場合です。主な依存関係からの回答。）
- 起動時のサービスの状態に関する情報（ビルド番号、ロードされた構成など）

**着信リクエストごと**:

- 各着信リクエストの基本情報：URL（個人を特定するデータ、別名PIIのスクラブ）、ユーザー/テナント/リクエストのディメンション、返されたレスポンスコード、リクエストからレスポンスへのレイテンシ、ペイロードサイズ、レコード数など（何でも）集合体データから何かを学ぶ必要があります）
- 予期しない例外に対する警告。トップコントローラー/インターセプターでのみキャッチされ、スタックトレースを使用して、リクエスト情報と一緒に、またはリクエスト情報と一緒にログに記録されます。500を返します。このコードは何が起こったのかわかりません。

**送信リクエストごと**:

- 各送信リクエストの基本情報：URL（個人を特定するデータ、別名PIIのスクラブ）、ユーザー/テナント/リクエストのディメンション、返された応答コード、リクエストからレスポンスまでのレイテンシ、ペイロードサイズ、返されたレコード数など。レポート依存関係の認識された可用性と遅延、および後の分析に役立つ可能性のあるスライス/クラスタリングデータを含みます。

## 推奨ツール

- [Azure Monitor](https://docs.microsoft.com/en-us/azure/azure-monitor/overview) - システムメトリック、ログ分析などを含むサービスの傘。
- [Grafana Loki](../tools/loki.md) - プロメテウスコミュニティからの学習に基づいて構築されたオープンソースのログ集約プラットフォームで、大規模なログデータの非常に効率的な収集と保存を実現します。
- [The Elastic Stack](https://www.elastic.co/what-is/elk-stack) - Logstash、Beats、Elastic search、Kibanaを利用したオープンソースのログ分析技術スタック。
- [Grafana](https://grafana.com) - オープンソースのダッシュボードと視覚化ツール。ログ、メトリクス、分散トレースデータソースをサポートします。

# 開発者エクスペリエンス（DevEx）

開発者の経験とは、開発者が変更を実装するために必要な重要なタスクを実行するのがどれほど簡単または難しいかを指します。ポジティブな開発者の経験は、これらのタスクがチームにとって比較的簡単であることを意味します（以下の対策を参照）。

重要なタスクを以下に示します。

- ビルド - 変更に構文エラーがないことを確認し、コンパイルします。
- テスト - すべての自動テストに合格することを確認します。
- 開始 - エンドツーエンドで起動して、デプロイされた環境での実行をシミュレートします。
- デバッグ - 開始したソリューションにデバッガーを接続し、ブレークポイントを設定し、コードをステップスルーし、変数を検査します。

これらの活動を可能な限り簡単にするために努力が費やされた場合、**その努力の見返りは、プロジェクトの実行期間が長くなり、チームが大きくなるほど増加します**。

## エンドツーエンドの定義

このドキュメントでは、ソリューションをエンドツーエンド（別名E2E）で実行するためのいくつかの参照を行います。このドキュメントの目的のためのエンドツーエンドは、チームによって所有、構築、および出荷されるソフトウェアに限定されます。他のチームまたはサードパーティベンダーが所有するシステムは、このドキュメントの目的ではE2Eの範囲に含まれません。

## 目標

- エンジニアがストーリーの受け入れと完了基準を満たすコードの記述に費やす時間を最大化します。
- 工具の手動セットアップと構成にかかる時間を最小限に抑えます
- エンドツーエンドのテストを容易にすることで、リグレッションと新しい欠陥を最小限に抑えます

## 影響

開発者の経験は、チームの日々の実行の効率に大きな影響を与える可能性があります。ポジティブな経験は、プロジェクトの全期間を通じて利益をもたらすことができます。特に新しい開発者がチームに参加するとき。

- 速度の向上 - チームは、開発/ローカル環境のセットアップ、リモート環境でのテストの待機、やり直し（欠陥の修正）などの付加価値のないアクティビティに費やす時間を短縮します。
- 品質の向上 - デバッグとテストが簡単な場合、開発者はそれをさらに実行します。これにより、導入される欠陥が少なくなります。
- より簡単なオンボーディングと導入 - 開発に不可欠なタスクが自動化されると、作成するドキュメントが少なくなり、その後、開始するために読む必要が少なくなります。

**最も重要なことは、顧客はコードを使用した後もずっとこれらのメリットを享受し続けることです。**

## 対策

### 最初のE2E結果までの時間（別名F5契約）

ソリューションを実行したことがないラップトップ/PCを想定すると、システム全体をエンドツーエンドでセットアップして実行し、結果を確認するのにどのくらい時間がかかりますか。

### 最初にコミットする時間

ローカルで検証/テストできる変更を加えるのにどのくらい時間がかかりますか。ローカルで検証/テストされた変更は、リグレッションを導入したり、変更を壊したりすることなく、テストケースに合格するものです。

## 参加

ポジティブな開発者エクスペリエンスを提供することは、チームの努力です。ただし、特定のメンバーは、チーム全体の説明責任を果たすために、さまざまな領域の所有権を取得できます。

### 開発リード - 基準を設定する

以下は、開発リーダーが開発エクスペリエンスの基準を設定する方法の例です。

- 開発環境を決定します（推奨されるIDE、ホスティングなど）
- ソース管理環境と必要なリポジトリの数を決定します
- 与えられた開発環境とリポジトリ構造は、重要な開発タスクを実行するためのステップに関して、チームが満たす期待を設定します
- DevExチャンピオンを指名

IDEの選択は、すべてのチームメンバーが同じIDEを使用する必要があることを義務付けることを意図したものではありません。ただし、この選択により、緊密な統合投資が優先される場所が決まります。たとえば、Visual Studio Codeが**推奨される**IDEである場合、チームはVSコードタスクの統合に焦点を合わせ、他のIDEの同様の統合よりも構成を起動します。チームメンバーは、チームに悪影響を与えない限り、好みのIDEを自由に使用できます。

### DevExチャンピオン - 反復的な改善点を特定する

DevExチャンピオンは、チームに前向きな開発者エクスペリエンスを提供する責任を負わせる責任を負います。以下は、DevExチャンピオンの責任の概要です。

- ソリューション開発者のエクスペリエンスを向上させる機会を積極的に模索する
- 開発リードと協力して、開発者エクスペリエンスに対するチームの期待を繰り返し改善します

- プロダクトオーナーと顧客と直接やり取りすることで、改善すべき領域を特定し、プロジェクトの実施目標に関して優先順位を付ける、バックログの実用的なストーリーを作成します。
- チームの他のメンバーの対象分野の専門家としての役割を果たします。チームがDevExの期待を実装する方法を決定し、逸脱を特定するのを支援します。

### チームメンバー - 期待を主張する

チームのチームメンバーは、前向きな開発者エクスペリエンスを提供するためにお互いに責任を負わせることもできます。以下は、チームメンバーがチームのDevExの期待が満たされていない場所を特定するのに役立つ領域の例です。

- プルリクエスト。ローカルで変更を試して、チームのDevExの期待に準拠しているかどうかを確認します。
- デザインレビュー。 ソリューションのDevExに悪影響を与える可能性のある提案を探します。これらには以下が含まれる可能性があります
  - テスト容易性が展開された環境での手動ステップに制限されている新しいテクノロジーの導入。
  - 新しいリポジトリの追加

### 新しいチームメンバー - 反復的な改善点を特定する

新しいチームメンバーは、文書化されていない[集合的知恵](https://en.wikipedia.org/wiki/Collective_wisdom)のインスタンスを識別するために独自の立場にあります。
以下は、DevExに関連する新しいチームメンバーの責任の概要です。

- オンボーディング中に不足している、不完全な、または不正確なドキュメントに遭遇した場合は、その問題を新しい欠陥として記録し、製品所有者に割り当ててトリアージする必要があります。
- オンボーディングドキュメントが存在しない場合は、新しいユーザーストーリーで行った手順に注意してください。新しいストーリーをプロダクトオーナーに割り当ててトリアージします。

## ファシリテーションガイダンス

以下の概要は、開発者の前向きな体験を促進するために採用できるいくつかの戦略の例です。各チームは、プロジェクトのコンテキスト内で前向きな開発経験が何を意味するかを定義する必要があります。さらに、スプリントやプロジェクトの回顧展などのフィードバックメカニズムを介して、時間をかけてそれを改善します。

### ホットキーを確立する

重要な各タスクにホットキーを割り当てます。

| 作業                 | Windowsの場合 |
| -------------------- | ------------ |
| ビルド                | CTRL+SHIFT+B |
| テスト                | CTRL+R,T     |
| デバッグの開始        | F5           |

### F5契約

F5契約は、次の手順でエンドツーエンドのソリューションを実行できるようにすることを目的としています。

1. クローン - git clone [`my-repo-url-here`]
2. 構成 - 個人に固有である必要がある構成値を設定します（つまり、.envファイルを更新します）
3. F5キーを押します - デバッグを添付してソリューションを起動します。

ほとんどのIDEには、ビルド、実行、およびアタッチのステップを自動化するために使用できる何らかの形式のタスクランナーがあります。これらを活用して、すべてのステップを可能な限り少ない手動ステップで実行できるようにしてください。

### DevExチャンピオンは積極的に改善を求めています

DevExチャンピオンは、チームが改善する機会がある領域を積極的に探す必要があります。たとえば、自分が行ったことが機能したかどうかを検証する前に、変更をラップトップから離れた環境に展開する必要がありますか。ローカルでデバッグするのではなく、実用的なソリューションに到達するためにこれを繰り返し実行する必要がありますか？これには、反復ごとに数分かかりますか？これは、環境の競合のために他の開発者をブロックしますか？

以下は、DevExチャンピオンが潜在的な機会を見つけるために使用できる式典です

- 回顧展。重要なタスクが困難または扱いにくいことに関連するフィードバックが提起されていますか？
- スタンドアップブロッカー。個人がブロックされたり、重要なタスクにつまずいたりしていませんか？

機会が特定されると、DevExチャンピオンは、これらを製品バックログの実用的なストーリーに変換できます。

### タスクをクロスプラットフォームにする

エンゲージメント中に標準化される重要なタスクについては、さまざまなプラットフォームが考慮されていることを確認してください。チームメンバーは異なるオペレーティングシステムを使用している可能性があり、タスクがクロスプラットフォームであることを確認することで、エクスペリエンスを向上させるための追加の機会が提供されます。

- [さまざまなプラットフォームを含める](./recipes/cross-platform-tasks.md)ようにタスクを構成する方法のガイダンスについては、「タスクのクロスプラットフォームレシピの作成」を参照してください。

### オンボーディングガイドを作成する

新しいチームメンバーをエンゲージメントに迎えるとき、コードベース、コーディング標準、チーム契約、チームカルチャーなど、彼らが順応してスピードを上げるための多くの領域があります。プロジェクトの範囲、プロセス、セットアップの詳細、および必要なソフトウェアを説明する一元化された場所でのオンボーディングガイドなどの強力なオンボーディングプラクティスを採用することにより、新しいメンバーは、効率的で成功し、価値のあるものになるために必要なすべてのリソースを持つことができます最初からチームメンバー。

オンボーディングガイドがどのように見えるかについてのガイダンスについては、[オンボーディングガイドのレシピ](./recipes/onboarding-guide-template.md)を参照してください。

### 重要なタスクを標準化する

重要なタスクを実行するために、ソリューションコンポーネント全体に共通の戦略を適用します

- ソリューションコンポーネントの構成を標準化する
- 各コンポーネントのテストの実行方法を標準化する
- 各コンポーネントの開始と停止の方法をローカルで標準化する
- 各コンポーネントの重要なタスクを文書化する方法を標準化する

この標準化により、チームはソリューションレベルですべてのコンポーネントにわたってこれらのタスクをより簡単に自動化できるようになります。以下のソリューションレベルの重要なタスクを参照してください。

### ソリューションレベルの重要なタスク

すべてのソリューションコンポーネントにわたって各重要なタスクを実行する機能を自動化します。例として、IDEでビルドアクションをマッピングして、ソリューション内の各コンポーネントのビルドタスクを実行します。さらに重要なのは、ソリューション内のすべてのコンポーネントを開始するようにIDE開始アクションを構成することです。これにより、マルチコンポーネントソリューションを扱う際に、エンジニアリングチームに大きな効率がもたらされます。

これが実装されていない場合、エンジニアはソリューション内のコンポーネントごとに重要なタスクを手動で繰り返す必要があります。この状況では、各重要なタスクを実行するために必要なステップ数に、システム内のコンポーネントの数を掛けます。

[構成手順+ビルド手順+開始/デバッグ手順+停止手順+テスト手順の実行+上記のすべての文書化]*[多くのソリューションコンポーネント]=手順が多すぎる

VS.

[構成手順+ビルド手順+開始/デバッグ手順+停止手順+テスト手順の実行+上記のすべての文書化]*[1つのソリューション]=最小手順数

### 可観測性

[可観測性](../observability/README.md)は、複雑な分散システムにおける開発者の予期しない課題を軽減します。プロジェクトのボトルネックをより迅速かつ正確に特定し、開発者がコード変更をデプロイしようとするときにパフォーマンスを向上させます。可観測性を追加すると、バグや壊れたコードを特定して解決する際のエクスペリエンスが向上します。これにより、現在および将来の本番環境での障害が少なくなります。

開発者が最良のエンジニアリングプラクティスと一緒に使用できる多くの可観測性戦略があります。これらのリソースは、ライフサイクル全体を通じて複雑なシステムの共有ビューを確保することにより、DevExを改善します。たとえば、ロギング、例外処理、関連するアプリケーションメトリックの公開によるコードの可観測性により、リアルタイムパフォーマンスの一貫した可視性が促進されます。可観測性の柱、[ロギング](../observability/pillars/logging.md)、[メトリック](../observability/pillars/metrics.md)、および[トレース](../observability/pillars/tracing.md)では、3つの特定のタイプの可観測性のそれぞれをいつ有効にするかについて詳しく説明します。

### リポジトリの数を最小限に抑える

ソリューションを複数のリポジトリに分割すると、上記の対策に悪影響を与える可能性があります。これは、プルリクエスト、自動テスト、継続的インテグレーション、継続的デリバリーなどの他の領域にも悪影響を与える可能性があります。IDEインスタンスと同様に、悪影響はリポジトリの数で乗算されます。

[クローンステップ+分岐ステップ+コミットステップ+CIステップ+プルリクエストのレビューとマージ]*[多くのソースコードリポジトリ]=ステップが多すぎます

VS.

[クローンステップ+分岐ステップ+コミットステップ+CIステップ+プルリクエストのレビューとマージ]*[1つのソースコードリポジトリ]=最小ステップ数

#### アトミックプルリクエスト

ソリューションが単一のリポジトリ内にカプセル化されている場合、プルリクエストが複数のレイヤーにわたる変更を表すこともできます。これは、変更によって複数のコンポーネント間の共有コントラクトを変更する必要がある場合に特に役立ちます。たとえば、ストーリーでは、APIエンドポイントを変更する必要があります。この戦略では、APIとWebクライアントを同じプルリクエストで更新できます。これにより、依存するプルリクエストがマージされるのを待っている間にメインブランチが一時的に壊れることを回避できます。

### ローカル開発のためのリモート依存関係を最小限に抑える

開発者のマシンを実行できないコンポーネントへの依存関係が少ないということは、開始に必要な手順が少ないことを意味します。したがって、依存関係が少ないと、上記の対策にプラスの影響があります。

次の戦略を使用して、これらの依存関係を減らすことができます

#### エミュレーターを使用する

利用可能な場合、エミュレーターは、通常はクラウド環境でのみ利用可能なテクノロジーの実装です。良い例は、[CosmosDBエミュレーター](https://docs.microsoft.com/en-us/azure/cosmos-db/local-emulator)です。

#### DI + Toggleを使用してリモート依存関係をモックします

ソリューションが開発者のマシンで実行できないテクノロジに依存している場合、そのソリューションのセットアップとテストは困難な場合があります。採用できる戦略の1つは、その依存関係をローカルで実行できる依存関係と交換する機能を作成することです。

ソリューションが所有するインターフェースの背後にあるリモート依存関係を持つレイヤーを抽象化します（リモート依存関係ではありません）。ローカルで実行できるテクノロジを使用して、そのインターフェイスの実装を作成します。使用するインスタンスを決定するファクトリを作成します。この決定は、環境構成（つまりトグル）に基づく可能性があります。次に、代わりにリモート技術に依存する元のクラスは、使用するインスタンスを提供するためにファクトリに依存する必要があります。

この戦略の多くは、適切な依存性注入手法やフレームワークを使用して簡略化できます。

ローカルで実行できるRabbitMQのAzureServiceBus実装を交換する以下の例を参照してください。

```typescript
interface IPublisher {
    send(message: string): void
}
class RabbitMQPublisher implements IPublisher {
    send(message: string) {
        //todo: send the message via RabbitMQ
    }
}
class AzureServiceBusPublisher implements IPublisher {
    send(message: string) {
        //todo: send the message via Azure Service Bus
    }
}
interface IPublisherFactory{
    create(): IPublisher
}
class PublisherFactory{
    create(): IPublisher {
        // use env var value to determine which instance should be used
        if(process.env.UseAsb){
            return new AzureServiceBusPublisher();
        }
        else{
            return new RabbitMqPublisher();
        }
    }
}
class MyService {
    //inject the factory
    constructor(private readonly publisherFactory: IPublisherFactory){
    }
    sendAMessage(message: string): void{
        //use the factory to determine which instance to use
        const publisher: IPublisher = this.publisherFactory.create();
        publisher.send(message);
    }
}
```

レシピセクションには、[生産性の高い内部開発ループの一部としてのDI](./recipes/client-app-inner-loop.md)に関するより完全な議論があります

# 継続的インテグレーション

![image](https://user-images.githubusercontent.com/7635865/76624154-c2c12800-6502-11ea-912d-a260c821ac41.png)

エンジニアリングチームは、プロジェクトのスプリント0中に先行投資を行い、コードを継続的に統合してシステム実行可能ファイルをターゲットクラウド環境にリリースする自動化された反復可能なパイプラインを確立することをお勧めします。各統合は、一連の検証テストに合格し、開発者チーム全体でエラーを表面化することを表明する自動ビルドプロセスによって検証する必要があります。

チームは、顧客向けのサービスコードを作成する前に、CI / CDパイプラインを実装することをお勧めします。これは通常、Sprint 0（N）で行われます。このようにして、エンジニアリングチームは、他の開発者に影響を与えることなく、自分の作業を個別に開発およびテストし、エンゲージメント全体で一貫したDevOpsワークフローを促進できます。

これらの[原則](https://martinfowler.com/articles/continuousIntegration.html)は、アジャイルソフトウェア開発ライフサイクルの[実践](https://en.wikipedia.org/wiki/Agile_software_development)を直接マッピングします。

## 目標

継続的インテグレーションの自動化は、ビルド統合エラーを減らし、開発クルー全体の速度を最大化することを目的としたソフトウェア開発ライフサイクルの不可欠な部分です。

堅牢なビルド自動化パイプラインは次のようになります。

- チームの速度を加速する
- 統合の問題を防ぐ
- リリース日の直前の混乱を避ける
- ローカル変更のシステム全体への影響に対する迅速なフィードバックサイクルを提供する
- ビルドとデプロイの段階を分ける
- ビルドの失敗/成功に関するメトリックを測定して報告します
- チーム全体の可視性を高め、より緊密なコミュニケーションを可能にします
- ビルドの自動化でおそらく最も重要な部分であるヒューマンエラーを削減します

## Gitで管理されるビルド定義

### プロジェクトのビルドに必要なコード/マニフェストアーティファクトは、プロジェクトのgitリポジトリ内に保持する必要があります。

- CIプロバイダー固有のビルドパイプライン定義は、プロジェクトのgitリポジトリ内に存在する必要があります。

## ビルド自動化

自動ビルドには、次の原則が含まれている必要があります。

### ビルドタスク

- コードプロジェクトを単一のビルドアーティファクトにコンパイルするビルドパイプライン内の単一のステップ。

### ユニットテスト

- ビルド定義には、一連の自動化された単体テストを実行して、アプリケーションコンポーネントがその設計を満たし、意図したとおりに動作することを確認するための検証手順が含まれています。

### コードスタイルチェック

- エンジニアリングチーム全体のコードは、合意されたコーディング標準に合わせてフォーマットする必要があります。このような標準はコードの一貫性を維持し、最も重要なこととして、チームと顧客が読み取りとリファクタリングを容易にします。コードスタイリングの一貫性により、プロジェクトスクラムチームとパートナーの共同所有権が促進されます。
- 選択できるオープンソースのコードスタイル検証ツールがいくつかあります（[コードスタイルチェック](https://github.com/checkstyle/checkstyle)、[StyleCop](https://en.wikipedia.org/wiki/StyleCop)）。プレイブックの[コードレビューセクション](../code-reviews/README.md#language-specific-guidance)には、多くの言語のリンターと推奨スタイルに関する提案があります。
- コードとドキュメントでは、可能な限り非包括的言語の使用を避ける必要があります。[インクルーシブリンティングのセクション](inclusive-linting.md)に従って、プロジェクトがチームと顧客の両方にとってインクルーシブな作業環境を促進するようにします。
- パイプラインのビルド段階に、コードクレデンシャルスキャナー、セキュリティリスク検出、静的分析などのセキュリティ分析ツールを組み込むことをお勧めします。Azure DevOPSの場合、[Microsoft Security Code Analysis 拡張機能](https://secdevtools.azurewebsites.net/#pills-onboard)をインストールすることで、パイプラインにセキュリティスキャンタスクを追加できます。GitHub Actionsは、[RIPSセキュリティスキャンソリューション](https://github.com/marketplace/actions/rips-security-scan)で同様の拡張機能をサポートしています。
- コード標準は、単一の構成ファイル内で維持されます。ビルドパイプラインには、最新のコミットのコードが既知のスタイル定義に準拠していることを表明するステップが必要です。

### スクリプトターゲットを構築する

- 1つのコマンドで、システムを構築する機能が必要です。これは、CIサーバーまたは開発者のローカルマシンで実行されているビルドにも当てはまります。

### IDEに依存しない
  
- スタンドアロンスクリプトを介して実行可能で、特定のIDEに依存しないビルドが不可欠です。ビルドパイプラインターゲットは、選択したIDEを介してデスクトップ上でローカルにトリガーできます。ビルドプロセスは、CIサーバー内でも実行できる十分な柔軟性を維持する必要があります。例として、ビルドプロセスをドッキングすると、VSCodeとIntelliJが[dockerプラグイン](https://code.visualstudio.com/docs/containers/overview)拡張機能をサポートするため、このレベルの柔軟性が提供されます。

### DevOps セキュリティチェック

- 早い段階でプロジェクトにセキュリティを導入します。[DevSecOpsセクション](dev-sec-ops/README.md)に従って、CIの一部としてセキュリティプラクティス、自動化、ツール、およびフレームワークを紹介します。

## 環境の依存関係を構築する

### 自動化されたローカル環境のセットアップ
  
- すべてのチームメンバーに対して一貫した開発者エクスペリエンスを維持することをお勧めします。ソフトウェアの依存関係のインストールとセットアップを合理化する、中央の自動化されたマニフェスト/プロセスが必要です。このようにして、開発者はCIサーバーで実行されているものと同じビルド環境をローカルに複製できます。
- ビルド自動化スクリプトでは、多くの場合、OSのランタイム環境内にプリインストールされた特定のソフトウェアパッケージとバージョンが必要です。ビルドプロセスは通常、これらの依存関係をバージョンロックするため、これにはいくつかの課題があります。
- チームのすべての開発者は、OSに関係なく、ローカルデスクトップからビルド環境をエミュレートできる必要があります。
- VS Codeを使用するプロジェクトの場合、[Dev Containers](../developer-experience/devcontainers.md)を活用することで、チーム全体でローカル開発者のエクスペリエンスを標準化することができます。
- ビルド自動化ツールチェーンを設計するときは、Docker、Maven、npmなどの確立されたソフトウェアパッケージツールを検討する必要があります。

### ローカル設定を文書化する

- ローカルビルド環境をセットアップするためのセットアッププロセスは、十分に文書化されており、開発者が簡単に理解できる必要があります。

## コードとしてのインフラストラクチャ

コードとして、次のできるだけ多くを管理します。

- 構成ファイル
- 構成管理（つまり、[terraform](https://github.com/microsoft/cobalt/blob/master/infra/modules/providers/azure/app-service/main.tf#L49)による環境変数の自動化）
- シークレット管理(つまり、[terraform](https://github.com/microsoft/cobalt/blob/master/infra/templates/az-isolated-service-single-region/app.tf#L84)を介してAzureシークレットを作成する)
- クラウドリソースプロビジョニング
- 役割の割り当て
- 負荷テストシナリオ
- 可用性アラート/監視ルールと条件

インフラストラクチャをアプリケーションコードベースから分離することで、エンジニアリングチームはクラウドネイティブアプリケーションに移行しやすくなります。

[Azure DevOPS](https://github.com/microsoft/terraform-provider-azuredevops)などのTerraformリソースプロバイダーは、開発者がビルドパイプライン変数、サービス接続、CI/CDパイプライン定義を簡単に管理できるようにします。

### TerraformとCobaltを使用したサンプルDevOPSワークフロー

![image](https://user-images.githubusercontent.com/7635865/76626035-652eda80-6506-11ea-8870-6070365f10d6.png)

### なぜ

- インフラストラクチャに対する反復可能で監査可能な変更により、クラウドリソースを手作業で配線することなく、既知の適切な構成にロールバックし、新しいステージやリージョンに迅速に拡張することが容易になります。
- [Cobalt](https://github.com/microsoft/cobalt)や[Bedrock](https://github.com/microsoft/bedrock)などのバトルテストおよびテンプレート化されたIACリファレンスプロジェクトにより、より多くのエンジニアリングチームが安全でスケーラブルなソリューションをはるかに速いペースで展開できるようになります
- アプリケーション開発者チームからクラウドネイティブコンピューティングの複雑さを抽象化することにより、「リフトアンドシフト」シナリオを簡素化します。

### IAC DevOPS：プルリクエストによる操作

- システム/Azure環境の現在の予想される状態を保持するリポジトリを中心に構築されたインフラストラクチャ展開プロセス。
- このリポジトリでコミットを行うことにより、実行中のシステムに操作上の変更が加えられます。
- Gitは、デプロイを監査し、以前の状態にロールバックするためのシンプルなモデルも提供します。

### インフラストラクチャが推奨するパターン

- インフラストラクチャをTerraform/ARM/Ansibleテンプレートのコードとして定義します
- テンプレートは、アプリのスケーリングとスループットのニーズに合わせた構成セットに重点を置いた、反復可能なクラウドリソーススタックです。

### IAC の原則

#### Azure 環境を自動化する

- すべてのクラウドリソースは、一連のインフラストラクチャを介してコードテンプレートとしてプロビジョニングされます。これには、シークレット、サービス構成設定、役割の割り当て、および監視条件も含まれます。
- Azure Portalは、環境リソースに関する読み取り専用ビューを提供する必要があります。環境に適用される変更は、IACCIツールチェーンを介してのみ行う必要があります。
- クラウド環境のプロビジョニングは、gitリポジトリにチェックインされたインフラストラクチャコードアーティファクトから駆動される反復可能なプロセスである必要があります。

#### IAC CI ワークフロー
  
- IACテンプレートファイルがgitベースのワークフローを通じて変更されると、CIビルドパイプラインは、ターゲットインフラストラクチャ環境の現在の状態をビルドし、検証し、期待される状態と調整します。これらの固定環境のインフラストラクチャ実行プランの候補は、実行プランを適用するパイプラインの展開段階の前に、ゲートチェックとしてクラウド管理者によってレビューされます。

#### クラウドリソースへの開発者の読み取り専用アクセス

- Azureポータルの開発者アカウントは、AzureのIAC環境リソースへの読み取り専用アクセス権を持っている必要があります。

#### シークレットオートメーション

- IACテンプレートは、シークレット自動化が統合されたCI/CDシステムを介して展開されます。シークレットや証明書に変更を直接Azureポータルで適用することは避けてください。

#### インフラストラクチャ統合テストの自動化

- エンドツーエンドの統合テストは、IAC CIプロセスの一部として実行され、Azure環境を使用する準備ができていることを検査および検証します。

#### インフラストラクチャのドキュメント

- 展開とクラウドリソーステンプレートのトポロジは、IAC gitリポジトリのREADME内で文書化され、十分に理解されている必要があります。
- ローカル環境とCIワークフローのセットアップ手順を文書化する必要があります。

## 構成の検証

アプリケーションは構成を使用してさまざまなランタイム動作を許可し、ファイルを使用してこれらの設定を保存することは非常に一般的です。開発者として、これらのファイルの編集中にエラーが発生し、アプリケーションの起動や正常な実行に問題が発生する可能性があります。構成の構文とセマンティクスの両方に検証手法を適用することで、アプリケーションをデプロイして実行する前にエラーを検出し、開発者（ユーザー）のエクスペリエンスを向上させることができます。

### アプリケーション構成ファイルの例

- JSON、複雑なデータ型とデータ構造をサポート
- YAML、複雑なデータ型と構造をサポートするJSONのスーパーセット
- OML、JSONのスーパーセット、および正式に指定された構成ファイル形式

### アプリケーション構成を別のステップとして検証する理由

- **Eより簡単なデバッグと時間の節約** - パイプラインの構成検証ステップにより、アプリケーションが失敗したことを見つけるためだけにアプリケーションを実行することを回避できます。デプロイして実行し、待機してから、構成に問題があることに気付く時間を節約できます。さらに、何が失敗したのか、そしてその理由を理解するためにログを調べる時間を節約できます。
- **ユーザー/開発者のエクスペリエンス向上** - 構成内の何かが適切な形式ではないことをユーザーに簡単に思い出させると、展開プロセスの成功の喜びと、何が悪かったのかを推測しなければならないという強い欲求不満の間にすべての違いが生じる可能性があります。たとえば、ブール値が必要な場合は、「True」や「False」などの文字列値、または「0」や「1」などの整数値のいずれかになります。構成の検証により、アプリケーションの意味が正しいことを確認します。
- **データの破損やセキュリティ違反を回避する** - データはユーザーや外部のWebサービスなどの信頼できないソースから到着するため、入力を検証することが特に重要です。そうしないと、エラーが発生したり、データが破損したり、さらに悪いことに、一連のインジェクション攻撃に対して脆弱になるリスクがあります。

### Json Schemaとは何ですか？

[JSON-Schema](https://json-schema.org/)は、JSONデータの構造と要件を説明するJSONドキュメントの標準です。これはJSONスキーマと呼ばれますが、JSONのスーパーセットであるため、YAMLにこのメソッドを使用することも一般的です。スキーマは非常に単純です。どのフィールドが存在する可能性があるか、どのフィールドが必須またはオプションであるか、どのデータ形式を使用するかを指摘します。他の検証ルールは、人間が読める情報とともに、その基本的な前提の上に追加できます。メタデータは、.jsonファイルでもあるスキーマに存在します。さらに、スキーマは検証シナリオの大部分をカバーしているため、JSON検証のすべての標準の中で最も広く採用されています。スキーマに解析しやすいJSONドキュメントを使用し、簡単に拡張できます。

### スキーマ検証を実装する方法は？

スキーマ検証の実装は、スキーマの生成と、それらのスキーマを使用したyaml/jsonファイルの検証の2つに分けられます。

### 世代

スキーマを生成するには、次の2つのオプションがあります。

- [コードから](https://json-schema.org/implementations.html#from-code) - コード内の既存のモデルとオブジェクトを活用して、カスタマイズされたスキーマを生成できます。

- [データから](https://json-schema.org/implementations.html#from-data) - 一般的な構成を反映するyaml/jsonサンプルを取得し、さまざまなオンラインツールを使用してスキーマを生成できます。

### 検証

スキーマには、JavaScript用の10以上を含む、さまざまな言語用の30以上の[バリデーター](https://json-schema.org/implementations.html#validators)があるため、自分でコーディングする必要はありません。

## 統合検証

ビルドのバグを迅速に特定する効果的な方法は、システムのベースライン機能を検証する信頼性の高い自動テストスイートに早期に投資することです。

### エンドツーエンドの統合テスト

- パイプラインにテストを含めて、ビルド候補が自動化されたビジネス機能アサーションに準拠していることを検証します。バグや壊れたコードは、失敗したテストや関連するスタックトレースなどのテスト結果で報告する必要があります。すべてのテストは、単一のコマンドで呼び出す必要があります。
- ビルドを高速に保ちます。データベース、外部サービス、モックデータの読み込みなどの依存関係をテストハーネスに取り込むことを決定する場合は、自動テストランタイムを検討してください。CIサーバーでの並列ビルドがオプションでない場合、遅いビルドは開発チームのボトルネックになることがよくあります。長い検証に最大タイムアウト制限を追加して、迅速に失敗し、チーム全体で高速を維持することを検討してください。

### 壊れたビルドをチェックインしないでください

- 自動ビルドチェック、テスト、lint実行などは、scmリポジトリに変更をコミットする前にローカルで検証する必要があります。[テスト駆動開発](https://martinfowler.com/bliki/TestDrivenDevelopment.html)は、開発ライフサイクルのできるだけ早い段階でバグや障害を特定するために開発クルーが検討する必要のあるプラクティスです。

### ビルドの失敗の報告

- ビルドステップが失敗した場合は、関連するログとスタックトレースを含めて、ビルドパイプラインの実行ステータスを失敗として報告する必要があります。

### 自動化データの依存関係をテストする

- ユニットおよびエンドツーエンドの統合テストに使用されるモックされたデータセットは、メインラインリポジトリにチェックインする必要があります。ビルドプロセスで外部データの依存関係を最小限に抑えます。

### コードカバレッジチェック

- ビルドステージ内にコードカバレッジツールを統合することをお勧めします。ほとんどのカバレッジツールは、テストカバレッジが最小しきい値（80％カバレッジ）を下回るとビルドに失敗します。カバレッジレポートは、変動の時系列を追跡するためにCIシステムに公開する必要があります。

## Git駆動型ワークフロー

### コミットに基づいて構築

- ベースラインリポジトリへのすべてのコミットは、CIパイプラインをトリガーして新しいビルド候補を作成する必要があります。
- ビルドアーティファクトは、コミットごとにビルド、パッケージ化、検証され、非本番環境に継続的にデプロイされます。リポジトリに対する各コミットは、統合マシンへのソースをチェックアウトし、ビルドを開始し、ビルドの結果をコミッターに通知するCI実行になります。

### 失敗したテストをコメントアウトしないでください

- メインラインブランチでテストをコメントアウトすることは避けてください。テストをコメントアウトすると、ビルドのステータスが誤って示されます。

### ブランチポリシーの施行

- コードレビューを開始する前にCIステージが通過したことを確認するために、保護された[ブランチポリシー](https://help.github.com/en/github/administering-a-repository/about-protected-branches)をメインブランチに設定する必要があります。コードレビュー承認者は、CIパイプラインの実行が最新のプッシュされたgit commitに合格すると、プルリクエストのレビューを開始します。
- 壊れたビルドは、プルリクエストのレビューをブロックする必要があります。
- メインブランチへの直接コミットを防止します。

### ブランチ戦略

- リリースブランチは、ビルドアーティファクトのターゲットクラウド環境へのデプロイを自動的にトリガーする必要があります。AzureDevOpsドキュメントサイトの[デプロイの管理](https://docs.microsoft.com/en-us/azure/devops/repos/git/git-branching-guidance?view=azure-devops#manage-deployments)セクションに追加のガイダンスがあります。

## 迅速かつ毎日配信

> 「定期的にコミットすることで、すべてのコミッターは競合する変更の数を減らすことができます。1週間分の作業をチェックインすると、他の機能と競合するリスクがあり、解決が非常に困難になる可能性があります。システムのある領域での初期の小さな競合により、チームが発生します。メンバーは、自分たちが行っている変更について連絡します。」

透明性の精神と開発クルー間の頻繁なコミュニケーションを受け入れることで、開発者は毎日のリズムでコードをコミットすることをお勧めします。このアプローチは、機能の進捗状況を可視化し、チーム全体のペアプログラミングを加速します。考慮すべきいくつかの原則は次のとおりです。

### 誰もが毎日gitリポジトリにコミットします

- 1日の終わりのチェックインコードには、少なくとも単体テストが含まれている必要があります。
- チェックインする前にビルドをローカルで実行して、CIパイプラインの障害が飽和状態にならないようにします。エラーの原因を確認し、コードをコミットするのではなく、できるだけ早く解決するようにしてください。開発者には、[無駄のないSDLCの原則](https://leankit.com/learn/lean/principles-of-lean-development/)に従うことをお勧めします。
- 作業を小さなチャンクに分離し、ビジネス価値に直接結び付け、段階的にリファクタリングします。

## 隔離された環境

ビルド検証の主要な目標の1つは、ステージング環境の障害を切り分けて特定し、本番環境のトラフィックの中断を最小限に抑えることです。E2E自動テストは、実稼働環境を（可能な限り）模倣する環境で実行する必要があります。これには、一貫性のあるソフトウェアバージョン、OS、テストデータボリュームシミュレーション、本番環境とのネットワークトラフィックの同等性などが含まれます。

### 本番のクローンでテストする

- 実稼働環境は、少なくともステージング環境（QAおよび/またはPre-Prod）に複製する必要があります。

### プルリクエストの更新により、段階的なリリースがトリガーされます

- プルリクエストに関連する新しいコミットは、統合環境へのビルド/リリースをトリガーする必要があります。本番環境は、このプロセスから完全に分離する必要があります。

### 固定環境全体でインフラストラクチャの変更を促進する

- コード変更としてのインフラストラクチャは、統合環境でテストし、すべてのステージング環境にプロモートしてから、システムユーザーのダウンタイムをゼロにして本番環境に移行する必要があります。

### 本番環境でのテスト

- 実稼働展開の自動テストを安全に実行するには、さまざまな[アプローチ](https://medium.com/@copyconstruct/testing-in-production-the-safe-way-18ca102d0ef1)があります。これらの一部には、次のものが含まれる場合があります。
  - 機能のフラグ付け
  - A/Bテスト
  - トラフィックシフト

## 最新リリースのアーティファクトへの開発者アクセス

私たちのdevopsワークフローは、開発者が最新のシステム実行可能ファイルを取得、インストール、実行できるようにする必要があります。リリース実行可能ファイルは、CI/CDパイプラインの一部として自動生成する必要があります。

### 開発者は最新の実行可能ファイルにアクセスできます

- チームのすべての開発者は、最新のシステム実行可能ファイルを利用できます。開発者がリリースアーティファクトを参照できる有名な場所があるはずです。

### リリースアーティファクトは、プルリクエストごとに公開されるか、メインブランチにマージされます

## 統合の可観測性

メインラインビルドに適用された状態の変更を利用可能にして、チーム全体に伝達する必要があります。ビルドとリリースのパイプライン障害からのログとステータスを一元化することは、壊れたビルドを調査する開発者にとって不可欠です。

TeamsまたはSlackをCI/CDパイプラインの実行と統合することをお勧めします。これにより、チームは継続的に障害に接続され、候補のステータスを構築できます。

### 継続的インテグレーションのトップレベルダッシュボード

- 最新のCIプロバイダーには、特定のダッシュボード内でビルドステータスを統合してレポートする機能があります。
- CIダッシュボードは、ビルドの失敗をgitcommitと関連付けることができる必要があります。

### プロジェクトのreadmeでステータスバッジを作成する

- プロジェクトのルートREADMEにビルドステータスバッジが含まれている必要があります。

### ビルド通知

- ビルドが完了したら、Teams/Slackなどのメッセージングプラットフォームに通知を送信するようにCIプロセスを構成する必要があります。これらの通知を統合および分離するために、別のチャネルを作成することをお勧めします。

## 参照

- [マーティンファウラーの継続的インテグレーションのベストプラクティス](https://martinfowler.com/articles/continuousIntegration.html)
- [Bedrockスタートガイドクイックガイド](https://github.com/microsoft/bedrock#getting-started)
- [Cobalt クイックスタートガイド](https://github.com/microsoft/cobalt/blob/master/docs/2_QUICK_START_GUIDE.md)
- [Terraform Azure DevOPS プロバイダー](https://github.com/microsoft/terraform-provider-azuredevops)
- [Azure DevOPS マルチステージパイプライン](https://docs.microsoft.com/en-us/azure/devops/pipelines/get-started/multi-stage-pipelines-experience?view=azure-devops)
- [Azure パイプラインの重要な概念](https://docs.microsoft.com/en-us/azure/devops/pipelines/get-started/key-pipelines-concepts?view=azure-devops)
- [Azure パイプライン環境](https://docs.microsoft.com/en-us/azure/devops/pipelines/process/environments?view=azure-devops)
- [Azureパイプラインのアーティファクト](https://docs.microsoft.com/en-us/azure/devops/pipelines/artifacts/artifacts-overview?view=azure-devops)
- [Azure Pipeline のアクセス許可とセキュリティの役割](https://docs.microsoft.com/en-us/azure/devops/pipelines/policies/permissions?view=azure-devops)
- [Azure環境の承認とチェック](https://docs.microsoft.com/en-us/azure/devops/pipelines/process/approvals?view=azure-devops&tabs=check-pass)
- [AzureでのTerraform入門ガイド](https://learn.hashicorp.com/terraform?track=azure#azure)
- [Terraformリモート状態のAzureセットアップ](https://docs.microsoft.com/en-us/azure/terraform/terraform-backend)
- [Terratest-ユニットおよび統合インフラストラクチャフレームワーク](https://terratest.gruntwork.io/)

# クレデンシャルスキャン

クレデンシャルスキャンは、プロジェクトを自動的に検査して、プロジェクトのソースコードにシークレットが含まれていないことを確認する方法です。シークレットには、データベースパスワード、ストレージ接続文字列、管理者ログイン、サービスプリンシパルなどが含まれます。

## クレデンシャルスキャンを行う理由

プロジェクトのソースコードにシークレットを含めると、それらのシークレットが不要な関係者に利用可能になる可能性があるため、重大なリスクがあります。秘密を知っている同じ人がソースコードにアクセスできるように見えても、プロジェクトが成長するにつれて、この状況は変わる可能性があります。シークレットをさまざまな場所に拡散すると、シークレットの管理、アクセス制御、および効率的な取り消しが困難になります。ソース管理にコミットされているシークレットは、ソースの履歴に保持されるため、破棄するのも困難です。
もう1つの考慮事項は、プロジェクトのコードをそのインフラストラクチャおよびデプロイメントの詳細に結合することは制限的であり、悪い習慣と見なされることです。ソフトウェア設計の観点から、コードは、それを実行するために使用されるランタイム構成から独立している必要があり、そのランタイム構成にはシークレットが含まれています。
そのため、コードとシークレットの間には明確な境界が必要です。シークレットはソースコードの外部で管理する必要があり（詳細は[こちら](../../../continuous-delivery/secrets-management/README.md)）、この境界に違反しないようにクレデンシャルスキャンを使用する必要があります。

## 資格情報スキャンの適用

理想的には、クレデンシャルスキャンは開発者のワークフローの一部として実行する必要があります（たとえば、[git pre-commitフック](https://githooks.com)を介して）が、開発者のエラーから保護するために、継続的インテグレーションプロセスの一部としてクレデンシャルスキャンを実施して、クレデンシャルがないことを確認する必要がありますプロジェクトのメインブランチにマージされることはありません。プロジェクトの資格情報スキャンを実装するには、次のことを考慮してください。

1. 機密情報を保存することを目的とした外部の安全なストアに秘密を保存する
1. シークレットスキャンツールを使用して、リポジトリの完全な履歴をスキャンしてシークレットの現在の状態を評価します
1. 自動化されたシークレットスキャンツールをCIパイプラインに組み込んで、意図しないシークレットのコミットを検出します
1. gitの `git add .` コマンドを避ける
1. 機密ファイルを .gitignore に追加します

## クレデンシャルスキャンのフレームワークとツール

レシピとシナリオ-

1. [Detect-secrets](./recipes/detect-secrets.md) - detect-secretsは、コードベース内のシークレットを検出するための適切な名前のモジュールです。
1. [Azure DevOps パイプライン内部でのシークレット検出](./recipes/detect-secrets-ado.md)
1. [Microsoft Security Code Analysis 拡張機能](https://docs.microsoft.com/en-us/azure/security/develop/security-code-analysis-overview)

追加ツール -

1. [CodeQL](https://securitylab.github.com/tools/codeql)  – Github セキュリティ。CodeQLを使用すると、データであるかのようにコードをクエリできます。脆弱性のすべての亜種を見つけるためのクエリを作成する
1. [Git-secrets](https://github.com/awslabs/git-secrets)  - パスワードやその他の機密情報をgitリポジトリにコミットできないようにします。

## 結論

秘密の管理はすべてのプロジェクトに不可欠です。シークレットを外部シークレットストアに保存し、この考え方をワークフローに組み込むと、セキュリティ体制が改善され、コードがよりクリーンになります。

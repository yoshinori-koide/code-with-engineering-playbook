# ユニットテスト

※ オリジナル: https://microsoft.github.io/code-with-engineering-playbook/automated-testing/unit-testing/

単体テストは、すべての開発者のツールボックスの基本的なツールです。単体テストは、コードのテストに役立つだけでなく、優れた設計手法を促進し、バグが本番環境に到達する可能性を減らし、コードがどのように機能するかについての例やドキュメントとしても役立ちます。適切に記述された単体テストは、開発者の効率を向上させることもできます。

単体テストも、最も一般的に誤解されている形式のテストの1つです。単体テストとは、非常に特殊なタイプのテストを指します。単体テストは次のようになります。

- **おそらく信頼できる** - 100％信頼できるはずなので、失敗はコードのバグを示します
- **高速** - ミリ秒単位で実行する必要があり、単体テストスイート全体が数秒以上かかることはありません
- **分離** - すべての外部依存関係を削除すると、信頼性と速度が保証されます

## ユニットテストを行う理由

単体テストを書くのが難しく、うまく書くのがさらに難しいことは周知の事実です。単体テストを作成すると、すべての機能の開発時間も長くなります。では、なぜそれらを書く必要があるのでしょうか？

ユニットテスト

- バグを早期に発見し、リグレッションを防ぐことでコストを削減します
- 変更に対する開発者の信頼を高める
- 開発者の内部ループをスピードアップ
- コードとしてのドキュメントとして機能する

詳細については、[上記ポイントのすべての詳細な説明](./why-unit-tests.md)を参照してください。

## ユニットテストデザインブロック

単体テストは最低レベルのテストであるため、通常、コンポーネントと依存関係はほとんどありません。

**テスト対象のシステム** (略して SUT) は、テスト対象の「ユニット」です。通常、これらはメソッドまたは関数ですが、言語によっては異なる場合があります。ただし、一般的には、ユニットをできるだけ小さくする必要があります。

ほとんどの言語には、**単体テストフレームワーク**とテストランナーの幅広いスイートもあります。これらのテストフレームワークにはさまざまな機能がありますが、基本機能は、テストを整理してすばやく実行するための方法である必要があります。

最後に、**ユニットテストコード**があります; 単体テストコードは一般に短く単純であり、コードにレイヤーと複雑さを追加するよりも繰り返しを優先します。

## ユニットテストの適用

単体テストの作成を開始するのは、セットアップがほとんど必要なく、コードだけであるため、他のいくつかのテストタイプよりもはるかに簡単です。各[テストフレームワーク](#test-frameworks)は、テストの編成方法と作成方法が異なりますが、単体テストを作成するための一般的な手法とベストプラクティスは普遍的です。

### テクニック

これらは、単体テストを作成するときに役立つ、一般的に使用されるいくつかの手法です。いくつかの例については、[抽象化と依存性注入を使用した単体テスト](authoring_example.md)ことや、[テスト駆動開発](tdd_example.md)に関するページを参照してください。

これらの手法のいくつかは、強く型付けされたオブジェクト指向言語に固有のものであることに注意してください。関数型言語とスクリプト言語には似たような手法があり、見た目が異なる場合がありますが、これらの用語はすべての単体テストの例で一般的に使用されています。

#### 抽象化

抽象化とは、正確な実装の詳細を取得し、代わりにそれを概念に一般化することです。この手法は、テスト可能な設計の作成に使用でき、特にオブジェクト指向言語でよく使用されます。単体テストの場合、抽象化は通常、ハードな依存関係を解消し、それを抽象化に置き換えるために使用されます。その抽象化により、コードの柔軟性が高まり、代わりに[モックまたはシミュレーター](mocking.md)を使用できるようになります。

依存関係を抽象化することの副作用の1つは、テストカバレッジのない抽象化がある可能性があることです。これは、単体テストが適切でない場合であり、すべてを単体テストすることは期待できません。依存関係などは、常にカバーされていないケースです。これが、堅牢な単体テストスイートがある場合でも、[統合テストまたは機能テスト](../integration-testing/README.md)を使用する必要がある理由です。これがないと、依存関係関数がキャッチされない方法が変更されます。

サードパーティの依存関係のラッパーを構築するときは、依存関係を呼び出す非常に単純な[ファサード](https://en.wikipedia.org/wiki/Facade_pattern)を使用して、実装をできるだけ少ないロジックで維持するのが最善です。

抽象化の使用例は[ここ](authoring_example.md#abstraction)にあります。

#### 依存性注入

[依存性注入](https://en.wikipedia.org/wiki/Dependency_injection)は、コードから依存性を抽出できるようにする手法です。依存クラスの通常のユースケースでは、依存関係はテスト対象のシステム内で構築および使用されます。これにより、2つのクラス間に強い依存関係が作成され、単独でのテストが特に困難になる可能性があります。依存関係は、REST APIをラップするクラスのようなものでも、ファイルアクセスのような単純なものでもかまいません。依存関係を構築するのではなく、システムに注入することで、依存関係の「逆制御」が可能になります「制御の反転」と「依存性注入」は別々の用語として使用されているように見えるかもしれませんが、[依存性注入は制御の反転をより具体的に言う方法である](https://martinfowler.com/articles/injection.html#InversionOfControl)と主張する人もいます。

[依存性注入の欠点](https://en.wikipedia.org/wiki/Dependency_injection#Disadvantages)の一つは、簡単に行き過ぎてしまう可能性があることです。もはやハードな依存関係はありませんが、インターフェース間の結合は依然として存在し、すべてのインターフェース実装をすべてのクラスに渡すことは、依存性注入を使用しない場合と同じくらい多くの欠点をもたらします。どの依存関係がどのクラスに注入されるかを意図的に考慮することは、保守可能なシステムを開発するための鍵です。

多くの言語には、ボイラープレートコードとオブジェクトの構築を処理する特別な依存性注入フレームワークが含まれています。この例としては、Java の[Spring](https://spring.io/)や[ASP.NET Core](https://docs.microsoft.com/en-us/aspnet/core/fundamentals/dependency-injection?view=aspnetcore-3.1)に組み込まれているものがあります。

依存性注入の使用例は[ここ](authoring_example.md#dependency-injection)にあります。

#### テスト駆動開発

テスト駆動開発（TDD）は、コードの設計方法の手法ではありませんが、最初からテスト可能な設計に導くコードを作成するための手法です。テスト駆動開発の基本的な前提は、最初にテストコードを記述し、次に、作成したばかりのテストと一致するようにテスト対象のシステムを記述することです。このようにして、すべてのテスト設計が事前に行われ、システムコードの記述が完了するまでに、すでに100％のテスト合格率とテストカバレッジになっています。また、テストが最初に作成されたため、テスト可能な設計がシステムに組み込まれていることも保証されます。

TDDと例の詳細については、[テスト駆動開発](./tdd_example.md)のページを参照してください。

### ベストプラクティス

#### アレンジ/アクト/アサート

ユニットテストコードを整理する一般的な形式の1つは、Arrange / Act/Assertと呼ばれます。これにより、単体テストが3つの異なる個別のセクションに分割されます。

1. 配置 - テストを実行するために必要なすべての変数、モック、インターフェース、および状態を設定します
2. 動作 - テスト対象のシステムを実行し、作成された上記のオブジェクトのいずれかを渡します
3. アサート - システムが適切に動作したことを特定の状態で確認します。

このパターンを使用してテストを作成すると、テストが非常に読みやすくなり、単体テストを読み取る必要がある将来の開発者にも馴染みがあります。

##### 例

 `MyObject` というクラスがあり文字列の配列と相互作用する`TrySomething` というメソッドがあったとして、このメソッドは配列に要素がない場合はfalseを返します。以下に配列に要素がない場合をチェックするテストを作成します。

```csharp
[Fact]
public void TrySomething_NoElements_ReturnsFalse()
{
    // Arrange
    var elements = Array.Empty<string>();
    var myObject = new MyObject();

    // Act
    var myReturn = myObject.TrySomething(elements);

    // Assert
    Assert.False(myReturn);
}
```

#### テストを小さく保ち、1つだけテストします

単体テストは短く、1つだけテストする必要があります。これにより、テストが失敗した行番号などを必要とせずに、失敗があったかどうかを簡単に診断できます。[Arrange/Act/Assert](#arrangeactassert)を使用するときは、「Act」フェーズで1つだけテストするようなものと考えてください。

1つのことをテストすることが「1つのことをアサートする」ことを意味するのか、「必要に応じて複数のアサートを使用して1つの状態をテストする」ことを意味するのかについては意見の相違があります。どちらにも長所と短所がありますが、ほとんどの技術的な意見の不一致と同様に、「正しい」答えはありません。いずれかの方法でテストを作成するときの一貫性がより重要です。

#### すべての単体テストに標準の命名規則を使用する

単体テスト名の標準規則が設定されていないと、単体テスト名は十分に説明的でないか、複数の異なるテストクラス間で重複することになります。標準を確立することは、コードの一貫性を維持するために重要であるだけでなく、優れた標準は、テストの可読性とデバッグ性も向上させます。この記事では、すべての単体テストに使用される規則は`UnitName_StateUnderTest_ExpectedResult`、しかし、他にも多くの可能な規則があります。重要なことは、一貫性があり、説明的であることです。上記のようなわかりやすい名前を付けると、失敗したときにテストを見つけるのが簡単になります。また、テストの期待と失敗の原因についてもすでに説明されています。これは、失敗したテストの名前だけがわかっているCI / CDシステムの失敗を調べるときに特に役立ちます。代わりに、テストの名前と失敗した理由を正確に把握できます（特に、テストフレームワークと組み合わせて失敗時に役立つ出力をログに記録します）。

### 避けるべきこと

回避することが重要な単体テストを作成する際のいくつかの一般的な落とし穴：

- スリープ - スリープは、依存関係に対して、あるべきではない要求を行っている可能性があることを示している可能性があります。一般に、コードがスリープなしで不安定な場合は、失敗する理由と、潜在的な状態変化を伝達するためのより信頼性の高い方法を導入することで不安定さを取り除くことができるかどうかを検討してください。ユニットテストにスリープを追加すると、ユニットテストの本来の信条の1つが破られます。テストは、ミリ秒単位のように高速である必要があります。テストに数秒かかる場合は、実行がより面倒になります。
- ディスクからの読み取り - ファイルで返される関数の期待値を実際に取得し、そのファイルを読み取って結果を比較するのは非常に魅力的です。これにより、システムドライブとの依存関係が作成され、単体テストを分離して100％信頼できる状態に保つという私たちの信条が破られます。ファイルシステムアクセスなどの外部依存関係は、断続的な障害を引き起こす可能性があります。さらに、これは、おそらくテストまたはテスト対象のユニットが複雑すぎるため、単純化する必要があることを示している可能性があります。
- サードパーティのAPIの呼び出し - 呼び出しているサードパーティのライブラリを制御していない場合、それが何をしているのかを確実に知ることは不可能であり、それを抽象化するのが最善です。そうしないと、コードを直接記述せずに、REST呼び出しやその他の潜在的な障害領域を作成している可能性があります。これは一般に、システムの設計が完全にテスト可能ではないことを示しています。単体テストで呼び出されないように、サードパーティのAPI呼び出しをインターフェイスまたはその他の構造でラップすることをお勧めします。

## ユニットテストのフレームワークとツール

### テストフレームワーク

ユニットテストのフレームワークは常に変化しています。すべてのユニットテストフレームワークの完全なリストについては、[ウィキペディアのページ](https://en.wikipedia.org/wiki/List_of_unit_testing_frameworks)を参照してください。フレームワークには多くの機能があり、特定のプロジェクトに最適な機能セットに基づいて選択する必要があります。

### モックフレームワーク

多くのプロジェクトは、単体テストフレームワークから始まり、模擬フ​​レームワークも追加します。モックフレームワークには用途があり、場合によっては要件になることもありますが、モックの多用に関連するより広範な影響とリスクを考慮せずに追加するものであってはなりません。

モックがプロジェクトに適しているかどうか、またはモックフリーのアプローチがより適切かどうかを確認するには、[モック](mocking.md)のページを参照してください。

### ツール

これらのツールを使用すると、インラインコードカバレッジを使用して単体テストを継続的に実行できるため、開発内部ループが非常に高速になり、TDDが簡単になります。

- [Visual Studio Live Unit Testing](https://docs.microsoft.com/en-us/visualstudio/test/live-unit-testing-intro?view=vs-2019)
- [Wallaby.js](https://wallabyjs.com/)
- [Infinitest](http://infinitest.github.io/) for Java
- [PyCrunch](https://plugins.jetbrains.com/plugin/13264-pycrunch--live-testing) for Python

## 考慮事項

### 統合テストへの責任の移転

状況によっては、システムが正しく機能していることを確認するために十分なコードカバレッジを提供するために、内部開発ループに統合テストを含めることを検討する価値があります。このアプローチを成功させるための前提条件は、ローカルとCI環境の両方で単体テストの速度に匹敵する速度で統合テストを実行できるようにすることです。.NETやSpringBootなどの最新のアプリケーションフレームワークを、外部依存関係に対する適切なモックまたはスタブアプローチと組み合わせることで、このようなシナリオをテストできるようにする優れた機能が提供されます。

通常、統合テストは、独立して開発されたモジュールが設計どおりに接続されていることを証明するだけです。統合テストのテストカバレッジを拡張して、システムの正しい動作を検証することもできます。十分なブランチおよびラインコードカバレッジを提供する責任は、単体テストから統合テストに移すことができます。システムの機能の特定のケースをテストするために必要ないくつかの単体テストの代わりに、フロー全体をカバーする1つの統合シナリオが作成されます。たとえば、APIの場合、受信したHTTP応答とそのコンテンツは、テスト中のリクエストごとに検証されます。これには、APIのコンポーネント間の統合とそのビジネスロジックの正確さの両方が含まれます。

このアプローチでは、効率的な統合テストを単体テストの拡張として扱うことができ、ハッピー/障害パスシナリオの検証の責任を引き継ぎます。内部の知識がなくても、システムをブラックボックスとしてテストできるという利点があります。コードのリファクタリングはテストに影響を与えません。TDDとしての一般的なテスト手法は、より高いレベルで適用できるため、受け入れテストによって推進される開発プロセスが実現します。プロジェクトの詳細にもよりますが、単体テストは依然として重要な役割を果たします。これらを使用して、下位レベルでテスト可能な設計を決定したり、必要に応じて複雑なビジネスロジックやコーナーケースをテストしたりできます。

## 結論

ユニットテストは非常に重要ですが、特効薬でもありません。適切な単体テストを行うことは、十分にテストされたシステムの一部にすぎません。ただし、適切な単体テストを作成すると、システムの設計に役立つだけでなく、リグレッションやバグをキャッチし、開発者の速度を上げるのに役立ちます。

## 参考資料

- [ユニットテストのベストプラクティス](https://docs.microsoft.com/en-us/dotnet/core/testing/unit-testing-best-practices)

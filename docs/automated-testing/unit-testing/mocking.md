# ユニットテストでのモック

※ オリジナル: https://microsoft.github.io/code-with-engineering-playbook/automated-testing/unit-testing/mocking/

単体テストを作成する際の重要な要素の1つは、システムの依存関係を削除し、それを制御する実装に置き換えることです。依存関係の代わりに人々が使用する最も一般的な方法はモックであり、このプロセスを容易にするためにモックフレームワークが存在します。

多くのフレームワークと記事は、テストダブルの違いに異なる意味を使用しています。テストダブルは、実際のオブジェクトの代わりに使用される「ふり」オブジェクトの総称です。この用語、およびこのページで使用されている他の用語は、 [MartinFowlerによって提供された定義](https://martinfowler.com/articles/mocksArentStubs.html#TheDifferenceBetweenMocksAndStubs)です。テストダブルの最も一般的に使用される形式はモックですが、モックがおそらく最良の選択ではなく、代わりに偽物を検討する必要がある場合が多くあります。

## スタブ

「モック」が使用されているほとんどの場合、実際に使用されているのは**スタブ**です。スタブは、テストが期待するものを返すだけで、他のロジックはありません。スタブは通常、予期しない入力を無視するか、常に同じものを返します。これらは通常、テストが期待する状態を設定する単純な1行のメソッドです。

スタブは、特にシステムの初期開発時に役立ちますが、ほぼすべてのテストで（さまざまな状態をテストするために）独自のスタブが必要になるため、これはすぐに繰り返しになり、多くの定型コードが含まれます。モックにスタブのみを使用するコードベースを見つけることはめったにありません。通常、それらは他のテストダブルとペアになっています。

スタブは、実行するためにいかなる種類のフレームワークも必要としませんが、通常、スタブをすばやく構築するためのモックフレームワークによってサポートされます。

### 利点

- フレームワークを必要とせず、セットアップが簡単です。

### 欠点

- 同じコードを何度も書き直す必要があり、多くの定型文が含まれます。

## モック

Fowlerは、**モック**を、受信することが期待される呼び出しの仕様を形成する期待を持つ事前にプログラムされたオブジェクトとして説明しています。言い換えると、モックは、特定の期待が置かれている依存関係の置換オブジェクトです。これらの期待は、サブメソッドが特定の回数呼び出されたことを検証したり、引数が特定の方法で渡されたりするようなものである可能性があります。

モックフレームワークはすべての言語に豊富にあり、一部の言語には単体テストパッケージにモックが組み込まれています。それらはユニットテストの作成を容易にし、それでも優れたユニットテストの実践を奨励します。

モックと他のほとんどのテストダブルの主な違いは、モックが**動作検証**を行うのに対し、他のテストダブルは**状態検証**を行うことです。動作検証では、テスト対象のシステムの実装が期待どおりであることをテストすることになりますが、状態検証では、実装はテストされず、システムへの入力と出力が検証されます。

動作検証の主な欠点は、実装に関連していることです。単体テストを作成する最大の利点の1つは、コードを変更するときに、単体テストに合格し続ければ、比較的安全な変更を行うことができるということです。メソッドの動作が変更されたためにテストを毎回更新する必要がある場合は、テストコードにバグが導入される可能性があるため、その信頼性が失われます。これはまた、開発時間を増加させ、フラストレーションの原因となる可能性があります。

たとえば、テストしているメソッドが5つのWebサービス呼び出しを行うと仮定します。モックを使用する場合、テストの1つは、これらの5つのWebサービス呼び出しが行われたことを確認することです。しばらくして、APIが更新され、1回のWebサービス呼び出しのみを行う必要があります。システムコードが変更されると、単体テストは1ではなく5つの呼び出しを想定しているため失敗します。テストを更新する必要があるため、変更の信頼性が低下し、バグが侵入する可能性のある領域が増える可能性があります。

上記の例では、単体テストは実装に依存するため、とにかく良いテストではないと主張する人もいますが、それは本当かもしれません。しかし、モック（特にこれらの検証を可能にするモックフレームワーク）を使用する際の最大の問題の1つは、これらのタイプのテストの作成を促進することです。これを可能にするモックフレームワークを使用しないことで、実装を検証するテストを作成するリスクを冒すことはありません。

### 利点

- 書きやすい。
- テスト可能な設計を奨励します。

### モッキングの欠点

- 動作テストでは、単体テストコードの保守性に問題が生じる可能性があります。
- 通常、フレームワークをインストールする必要があります（または、フレームワークがない場合は、多くの定型コード）

## 偽物

**偽**のオブジェクトには実際に機能する実装がありますが、通常はショートカットを使用するため、本番環境に適さない場合があります。偽物を使用する一般的な例の1つは、インメモリデータベースです。通常、データベースでアプリケーションの実行間のどこかにデータを保存できるようにしますが、ユニットテストを作成する場合は、保存されているデータベースAPIの偽の実装がある場合メモリ内のすべてのデータ。これらをユニットテストに使用でき、抽象化を中断せず、テストを高速に保つことができます。

偽物を書くことは、完全な実装であり、独自の単体テストのスイートを持つことができるため、他のテストダブルよりも時間がかかります。ただし、この意味では、ダウンストリームの依存関係として使用する前に、テストダブルのバグが徹底的にテストされているため、コードの信頼性がさらに高まります。

モックと同様に、偽物もテスト可能なデザインを促進しますが、モックとは異なり、作成するためのフレームワークは必要ありません。偽物を書くことは、他の実装クラスを書くことと同じくらい簡単です。偽物はテストコードにのみ含めることができますが、多くの場合、製品コードに「プロモート」され、場合によっては、完全な単体テストで同じ標準に保持されているため、製品コードから開始することもできます。特に、他の開発者が使用できるライブラリまたはAPIを作成する場合、製品コードに偽物を提供することは、それらの開発者が独自のモック実装を作成する必要がなくなることを意味し、コードの再利用性をさらに高めます。

### 利点

- フレームワークは必要ありません。他の実装と同じです。
- テスト可能な設計を奨励します。
- コードは製品コードに「プロモート」できるので、無駄な労力はありません。

### 欠点

- 実装に時間がかかります。

## 結論

単体テストでテストダブルを使用することは、健全なテストスイートを作成するための重要な部分です。モックフレームワークを検討し、テストダブルを使用する場合、最初からモックフレームワークと統合することの将来の影響を考慮することが重要です。フレームワークをモックする特定の機能が不可欠であるように見える場合もありますが、通常、フレームワークが必要な場合、コード自体が十分に抽象化されていないことを示しています。

可能であれば、モックフレームワークなしで開始し、偽の実装を作成しようとすると、より健全なコードベースにつながりますが、それが不可能な場合は、チームの技術リーダーがモックが乱用される可能性のあるケースを見つける責任があります。実装の詳細について多くのことを述べたり、正しいことをテストしなかったりします。
